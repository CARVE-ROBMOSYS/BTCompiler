-- // This document contains no USA or EU export controlled technical data.
--
-- // CARVE has received funding from the European Union's Horizon 2020 research and
-- // innovation programme under grant agreement No 732410, in the form of financial
-- // support to third parties of the RobMoSys project.

MODULE bt_tick_generator(top_level_bt)
  ASSIGN
    init(top_level_bt.visit) := bt_visit_enable;
    next(top_level_bt.visit) :=
      case
        top_level_bt.output = bt_output_none : bt_visit_no;
        TRUE : bt_visit_enable;
      esac;


MODULE bt_sequence(left_bt, right_bt)
  VAR
    visit : { bt_visit_no, bt_visit_enable, bt_visit_disable };
    cached_left_bt_output : { bt_output_none,
                              bt_output_disable,
                              bt_output_running,
                              bt_output_false,
                              bt_output_true };
  ASSIGN
    left_bt.visit := visit;
    right_bt.visit :=
      case
        left_bt.output = bt_output_none : bt_visit_no;
        left_bt.output = bt_output_true : bt_visit_enable;
        TRUE : bt_visit_disable;
      esac;
    init(cached_left_bt_output) := bt_output_none;
    next(cached_left_bt_output) :=
      case
        left_bt.output = bt_output_none : cached_left_bt_output;
        TRUE : left_bt.output;
      esac;
  DEFINE
    output :=
      case
        right_bt.output = bt_output_none : bt_output_none;
        right_bt.output = bt_output_disable : cached_left_bt_output;
        TRUE : right_bt.output;
      esac;


MODULE bt_fallback(left_bt, right_bt)
  VAR
    visit : { bt_visit_no,
              bt_visit_enable,
              bt_visit_disable };
    cached_left_bt_output : { bt_output_none,
                              bt_output_disable,
                              bt_output_running,
                              bt_output_false,
                              bt_output_true };
  ASSIGN
    left_bt.visit := visit;
    right_bt.visit :=
      case
        left_bt.output = bt_output_none : bt_visit_no;
        left_bt.output = bt_output_false : bt_visit_enable;
        TRUE : bt_visit_disable;
      esac;
    init(cached_left_bt_output) := left_bt.output;
    next(cached_left_bt_output) :=
      case
        left_bt.output = bt_output_none : cached_left_bt_output;
        TRUE : left_bt.output;
      esac;
  DEFINE
    output :=
      case
        right_bt.output = bt_output_none : bt_output_none;
        right_bt.output = bt_output_disable : cached_left_bt_output;
        TRUE : right_bt.output;
      esac;


MODULE bt_skill(from_skill)
  VAR
    visit : { bt_visit_no, bt_visit_enable, bt_visit_disable };
  DEFINE
    output := from_skill;


MODULE shared_resource(consumer_1, consumer_2)
  DEFINE
    is_mutual_exclusion_satisfied :=
      !(consumer_1.resource_held & consumer_2.resource_held);


MODULE bt_spec(from_skill_is_battery_ok, from_skill_goto_recharge, from_skill_patrol)
  VAR
    goto_recharge : bt_skill(from_skill_goto_recharge);
    patrol : bt_skill(from_skill_goto_recharge);
    is_battery_ok : bt_skill(from_skill_is_battery_ok);
    recharge_if_needed : bt_fallback(is_battery_ok, goto_recharge);
    root : bt_sequence(recharge_if_needed, patrol);
    r_tick : bt_tick_generator(root);


MODULE main
  VAR
    to_skill_goto_recharge : { bt_visit_no, bt_visit_enable, bt_visit_disable };
    from_skill_goto_recharge : { bt_output_none, bt_output_running, bt_output_false, bt_output_true, bt_output_disable };
    from_skill_patrol : { bt_output_none, bt_output_running, bt_output_false, bt_output_true, bt_output_disable };
    from_skill_is_battery_ok : { bt_output_none, bt_output_running, bt_output_false, bt_output_true, bt_output_disable };
    bt_inst : bt_spec(from_skill_is_battery_ok, from_skill_goto_recharge, from_skill_patrol);
  DEFINE
    to_skill_patrol := bt_inst.patrol.visit;
    to_skill_is_battery_ok := bt_inst.is_battery_ok.visit;
  ASSIGN
    to_skill_goto_recharge := bt_visit_no; --bt_inst.goto_recharge.visit;
